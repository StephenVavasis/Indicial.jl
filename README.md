# Indicial

Indicial provides a macro to encode inner loops over arrays
without incurring the heap-allocation penalty of working
directly with array objects.

[![Build Status](https://travis-ci.org/StephenVavasis/Indicial.jl.svg?branch=master)](https://travis-ci.org/StephenVavasis/Indicial.jl)

## Overview

This package addresses a problem that commonly occurs in finite element codes,
namely, many linear algebraic operations need to take place on "small" vectors
inside a loop.  For example consider saxpy with indirect addressing.  Suppose
`x` and `y` are both short
arrays, `ind` is an integer array, and `a` is a scalar.  One could write:

```
y = y + a * x[ind]
```

but this requires heap allocation for a new copy of `y`.  Slightly better is

```
y[:] = y + a * x[ind]
```

but there is still heap allocation for the temporary arrays on the RHS.  To
eliminate all heap allocation requires an explicit loop:

```
  for j = 1 : size(y,1)
      y[j] += a * x[ind[j]]
  end
```

The purpose of this package is to provide a way to encode these one-statement
loops more simply.  For the above example, one uses the macro call
```
  @indicial y[~1] += a * x[ind[~1]]
```
The notation `~1` by the macro is used to mark an implicit subscript;
the package replaces this implicit subscript by an actual loop variable
inside the for-loop generated by the macro.  Note that for this
statement to be valid, `y` must already have been initialized as a 1-dimensional
array.  Presumably the initialization takes place outside of the main loop
(because the initialization certainly requires a heap allocation).

  
## Usage

Following the ``@indicial`` invocation should be an assignment statement, one
of `=`, `+=` or `-=`.
This assignment statement has arrays with subscripts.  The subscripts can
either be ordinary subscripts or the special subscripts of the package
``~1``, ``~2``, etc.  Each of these refers to a unique subscript and
each distinct subscript implies
an additional loop.  A subscript that occurs on the LHS of the assignment but
not the right implies a broadcast operation.  For example, to initialize
an identity matrix, one could say:

```
  @indicial y[~1,~2] = 0.0
  @indicial y[~1,~1] = 1.0
```


The Indicial package also adopts the Einstein convention, which means that
an index that occurs twice on the RHS but not on the LHS is automatically
summed.  Thus, to take the trace of a matrix followed by a matrix-vector
multiply, one writes

```
  @indicial traceA = A[~1,~1]
  @indicial y[~1] = A[~1,~2] * x[~2]
```

It is an error for an index that does not appear on the LHS
to appear on the RHS with multiplicity other than 2.

## Syntax note

This macro hijacks the tilde, which is usually
the bitwise-not operator.  This means that if your
expression happens to use bitwise-not in front of an integer literal,
then the expression needs to be reorganized.

The Julia
documentation apparently does not indicate the precedence of bitwise-not,
but it appears to be quite high, which means that a usage like
```
  @indicial y[~1] = x[~1 + 1]
```
to shift a vector
should work as intended, but if you want to be safe, you can write
```
  @indicial y[~1] = x[(~1) + 1]
```

